<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>[WebGL] Grimoire.js で太陽を表示させてみるテスト（改2） - js do it</title>
<meta name="Description" content="" />
<meta name="Keywords"  content="" />

<link rel="stylesheet" type="text/css" media="screen,print" href="style.css" />
</head>
<body>
<!-- generated by: jsdo.it - http://jsdo.it/cx20/chhM -->
<!-- Copyright cx20 - http://jsdo.it/cx20 -->
<!-- Licensed under MIT License - http://www.opensource.org/licenses/mit-license.php -->
<!-- grimoire-preset-basic.js v1.11.5 -->
<script src="https://unpkg.com/grimoirejs-preset-basic@1.11.5/register/grimoire-preset-basic.js"></script>
<script src="https://unpkg.com/grimoirejs-forward-shading@1.7.3/register/grimoire-forward-shading.js"></script>

<script type="text/sort" id="shader" typeName="newMaterial">
@Pass{
  @CullFace(FRONT)
  //FS_PREC(mediump,float)
  FS_PREC(highp,float)  // iPhone だと mediump → highp にしないと正しく表示されない模様
  
  #ifdef VS
    attribute vec3 position;
    attribute vec2 texCoord;
    uniform mat4 _matPVM;
    @{default:1.1}
    uniform float edgeScaling;
    void main(){
        gl_Position = _matPVM * vec4(position * 10.0, 1.0);
    }
  #endif
  
  #ifdef FS
    @{type:"color"}
    uniform vec4 edgeColor;
    uniform vec2 _viewportSize;
    uniform float _time;
  
    // Yuldashev Mahmud Effect took from shaderToy mahmud9935@gmail.com

    float snoise(vec3 uv, float res)
    {
        const vec3 s = vec3(1e0, 1e2, 1e3);
        
        uv *= res;
        
        vec3 uv0 = floor(mod(uv, res))*s;
        vec3 uv1 = floor(mod(uv+vec3(1.), res))*s;
        
        vec3 f = fract(uv); f = f*f*(3.0-2.0*f);
    
        vec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,
                      uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);
    
        vec4 r = fract(sin(v*1e-1)*1e3);
        float r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);
        
        r = fract(sin((v + uv1.z - uv0.z)*1e-1)*1e3);
        float r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);
        
        return mix(r0, r1, f.z)*2.-1.;
    }
    
    void main( void ) {
        float time = _time / 1000.0;
    
        vec2 p = -.5 + gl_FragCoord.xy / _viewportSize;
        p.x *= _viewportSize.x/_viewportSize.y;
        
        float color = 3.0 - (3.*length(2.*p));
        
        vec3 coord = vec3(atan(p.x,p.y)/6.2832+.5, length(p)*.4, .5);
        
        for(int i = 1; i <= 7; i++)
        {
            float power = pow(2.0, float(i));
            color += (1.5 / power) * snoise(coord + vec3(0.,-time*.05, time*.01), power*16.);
        }
        gl_FragColor = vec4( color, pow(max(color,0.),2.)*0.4, pow(max(color,0.),3.)*0.15 , 1.0);
    }
    #endif
}

@Pass{
  @CullFace(BACK)
  //FS_PREC(mediump,float)
  FS_PREC(highp,float)  // iPhone だと mediump → highp にしないと正しく表示されない模様
  
  varying vec2 vUv;

  #ifdef VS
	// forked from "Shader - Fireball" http://stemkoski.github.io/Three.js/Shader-Fireball.html
	attribute vec3 position;
	attribute vec3 normal;
	attribute vec2 texCoord;
	uniform mat4 _matPVM;

	@{default:"../../assets/y/8/i/H/y8iHs.png"}
	uniform sampler2D noiseTexture;
	@{default:0.5}
	uniform float noiseScale;

	@{default:"../../assets/y/8/i/H/y8iHs.png"}
	uniform sampler2D bumpTexture;
	@{default:0.15}
	uniform float bumpSpeed;
	@{default:40.0}
	uniform float bumpScale;

	uniform float _time;

	void main() 
	{ 
	    float time = _time / 1000.0;
	    vUv = texCoord;
	    
	    vec2 uvTimeShift = vUv + vec2( 1.1, 1.9 ) * time * bumpSpeed;
	    vec4 noiseGeneratorTimeShift = texture2D( noiseTexture, uvTimeShift );
	    vec2 uvNoiseTimeShift = vUv + noiseScale * vec2( noiseGeneratorTimeShift.r, noiseGeneratorTimeShift.g );
	    // below, using uvTimeShift seems to result in more of a "rippling" effect
	    //   while uvNoiseTimeShift seems to result in more of a "shivering" effect
	    vec4 bumpData = texture2D( bumpTexture, uvTimeShift );

	    // move the position along the normal
	    //  but displace the vertices at the poles by the same amount
	    float displacement = ( vUv.y > 0.999 || vUv.y < 0.001 ) ? 
	        bumpScale * (0.01 + 0.005 * sin(time)) :  
	        bumpScale * bumpData.r * 0.05;
        vec3 newPosition = (position * 4.0 + normal * displacement) / 1.0;
	    
        gl_Position = _matPVM * vec4( newPosition, 1.0 );
        //gl_Position = _matPVM * vec4( position * 5.0, 1.0 );
	}
  #endif
  
  #ifdef FS
	@{default:"../../assets/c/C/I/q/cCIqn.jpg"}
	uniform sampler2D baseTexture;
	@{default:0.02}
	uniform float baseSpeed;
	@{default:4.0}
	uniform float repeatS;
	@{default:4.0}
	uniform float repeatT;

	@{default:"../../assets/y/8/i/H/y8iHs.png"}
	uniform sampler2D noiseTexture;
	@{default:0.5}
	uniform float noiseScale;

	@{default:"../../assets/c/c/I/q/ccIqn.jpg"}
	uniform sampler2D blendTexture;
	@{default:0.01}
	uniform float blendSpeed;
	@{default:0.25}
	uniform float blendOffset;

	uniform float _time;
	@{default:1.0}
	uniform float alpha;

	void main() 
	{
	    float time = _time / 1000.0;

        vec2 uvTimeShift = vUv + vec2( -0.7, 1.5 ) * time * baseSpeed;    
	    vec4 noiseGeneratorTimeShift = texture2D( noiseTexture, uvTimeShift );
	    vec2 uvNoiseTimeShift = vUv + noiseScale * vec2( noiseGeneratorTimeShift.r, noiseGeneratorTimeShift.b );
	    vec4 baseColor = texture2D( baseTexture, uvNoiseTimeShift * vec2(repeatS, repeatT) );

	    vec2 uvTimeShift2 = vUv + vec2( 1.3, -1.7 ) * time * blendSpeed;    
	    vec4 noiseGeneratorTimeShift2 = texture2D( noiseTexture, uvTimeShift2 );
	    vec2 uvNoiseTimeShift2 = vUv + noiseScale * vec2( noiseGeneratorTimeShift2.g, noiseGeneratorTimeShift2.b );
	    vec4 blendColor = texture2D( blendTexture, uvNoiseTimeShift2 * vec2(repeatS, repeatT) ) - blendOffset * vec4(1.0, 1.0, 1.0, 1.0);

	    vec4 theColor = baseColor + blendColor;
	    theColor.a = alpha;
	    gl_FragColor = theColor;
	}  
  #endif
}
</script>

<script type="text/goml" id="canvas">
<goml width="fit" height="fit">
  <scene>
    <camera position="0,15,5">
      <camera.components>
        <MouseCameraControl/>
      </camera.components>
    </camera>
    <light rotation="0d,45d,0d" type="directional" color="white"  intensity="3.0" />
    
    <mesh geometry="sphere" position="0,0,0" material="new(newMaterial)" />
  </scene>
</goml>
</script>


<script type="text/javascript" src="index.js"></script>
</body>
</html>
