<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>[WebGL] Grimoire.js で正解するカドっぽいものを表現してみるテスト（改） - js do it</title>
<meta name="Description" content="" />
<meta name="Keywords"  content="" />

<link rel="stylesheet" type="text/css" media="screen,print" href="style.css" />
</head>
<body>
<!-- generated by: jsdo.it - http://jsdo.it/cx20/4iKk -->
<!-- Copyright cx20 - http://jsdo.it/cx20 -->
<!-- Licensed under MIT License - http://www.opensource.org/licenses/mit-license.php -->
<!-- grimoire-preset-basic.js v1.10.16 -->
<script src="https://unpkg.com/grimoirejs-preset-basic@1.10.16/register/grimoire-preset-basic.js"></script>

<script type="text/sort" id="shader" typeName="fractalShader">
@Pass{
FS_PREC(highp,float)
#ifdef VS
  attribute vec3 position;
  void main(){
    gl_Position = vec4(position, 1.);
  }
#endif

#ifdef FS
  // forked from http://glslsandbox.com/e#39870.0
  uniform float _time;
  uniform vec2 _viewportSize;
  #define MAX_ITER 3
  
  vec3 hsv(float h, float s, float v){
    vec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(vec3(h) + t.xyz) * 6.0 - vec3(t.w));
    return v * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), s);
  }

  void main( void )
  {
    //vec4 p = vec4(gl_FragCoord.xy, 0.0, 1.0)/_viewportSize.x - 0.5;
    vec4 p = vec4(gl_FragCoord.xy / _viewportSize * 1.0 - 0.55, 0.5, 1.0);
    vec4 r = p - p;
    vec4 q = r;
    q.zw -= _time * 0.00005 + 1.0;
    
    for (float i = 1.0; i > 0.; i -= 0.01) {

        float d = 0.0;
        float s = 1.0;

        for (int j = 0; j < 7; j++) {
            r = abs(mod(q * s + 1.0, 2.0) - 1.0);
            r = max(r, r.yzxw);
            d = max(d,(0.3 - length(r * 0.95) * 0.3) / s);
            s *= 3.75;
        }

        q += p * d;
        
        gl_FragColor = p * p + i / 2.0;
        //gl_FragColor = p - p + i / 2.0; // mono color
        gl_FragColor.rgb = hsv(mod(_time/5000.0,1.0), 1.0, 1.0) * 0.3 + gl_FragColor.rgb;

        if(d < 1e-5) break;
    }
    gl_FragColor.a = 1.0;
  }
#endif
}
</script>

<script type="text/sort" id="shader" typeName="postEffect">
@Pass{
// FS_PREC(mediump, float)
FS_PREC(highp, float)  // iPhone で _time / 1000 が桁落ちする問題の対応
varying vec2 vTexCoord;

#ifdef VS
attribute vec3 position;
attribute vec2 texCoord;

void main(){
  gl_Position = vec4(position,1);
  vTexCoord = vec2(1) - texCoord;
}

#endif

#ifdef FS
uniform sampler2D texture;
uniform float _time;

// forked from  2Light's "chromatic aberration test" https://www.shadertoy.com/view/4sS3Dw
void main(){
    vec2 uv = vTexCoord;
    vec4 color = vec4(0.0);
    float time = _time / 1000.0;

    float go = sin(time) * 0.02;
    float go2 = sin(time) * 0.02;
    vec2 strenght = vec2(5, 5);

    color.r = texture2D(texture, -uv - vec2(go, 0.0) * strenght).r;
    color.g = texture2D(texture, -uv - vec2(0.005, go2) * strenght).g;
    color.b = texture2D(texture, -uv).g;
    color.a = 1.0;

    gl_FragColor = color;
}
#endif
}
</script>
<script type="text/goml" id="canvas">
<goml width="fit" height="fit">
  <!-- <import-material typeName="shader" src="index.sort"/> -->
  <renderer>
    <render-buffer name="rb"/>
    <texture-buffer name="bb1"/>
    <texture-buffer name="b1"/>
    <render-quad material="new(fractalShader)" out="b1"/>
      <render-scene out="bb1" depthBuffer="rb"/>
      <render-quad material="new(postEffect)" texture="backbuffer(bb1)" out="default"/>
  </renderer>
  <scene>
    <camera position="0,0,5">
      <camera.components>
        <MouseCameraControl/>
      </camera.components>
    </camera>
    <mesh geometry="cube" texture="backbuffer(b1)">
      <mesh.components>
        <Rotate />
      </mesh.components>
    </mesh>
  </scene>
</goml>
</script>



<script type="text/javascript" src="index.js"></script>
</body>
</html>
